@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@200;300;400;500;600;700;800;900&display=swap');

*{
    padding: 0;
    margin: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Montserrat', sans-serif;
    line-heigth: 1.5
}

/** -------- Navigations-Styling --------- **/

.navbar {
    position: fixed; /** An element with position: fixed; is positioned relative to the viewport, which means it always stays in the same place even if the page is scrolled. **/
    top: 0;
    left: 0;
    width: 100%;
    padding: 1.4rem 2rem; /** The 'rem'-unit sets the padding-size relative to the browsers base padding-size (= the <html>-element), and will not inherit from its parents. In our case, the default padding & margin are 16px, which implies:
    - A (16 * 1.4) == 22.4px for the top- & bottom-padding.
    - A (16 * 2) == 32px for the left- & right-padding.
     **/
    z-index: 999; /* he z-index property specifies the 'stack-order' of an element. In general, the more nested a <div> is INSIDE a bunch of other <div>'s, the higher it is stacked uppon the other <div>'s. Note that, an element with greater stack order is always in front of an element with a lower stack order. 
    --> ! Cool (Key to note): We define the z-index on our highest Nav-Container, which will also guarantee that the "hidden"-navigation will apear on top of every other element!
    - Here, we have a high number for the z-index (= 999), which means that it will be layered above (998) other elements. */
}

.brand-and-toggler {
    display: flex; 
    justify-content: space-between; /*Macht, dass das Burger-Symbol der Navigation ganz auf die rechte Seite positioniert wird und - gleichzeitig - dass sich das Logo auf der linken Seite befindet. */
    align-items: center; /* Vertikale Zentrierung soll mittig sein. */
}

.navbar-brand {
    color: #fff;
    font-weight: 800;
    font-size: 2rem; /* 2rem entspricht 32px (= 2 * 16px). */
    text-decoration: none;
}

.nav-show-btn {
    background: none;
    border: none;
    color: #fff;
    font-size: 1.8rem;
    cursor: pointer;
    outline: 0; /* An outline is a line that is drawn around elements, OUTSIDE the borders, to make the element "stand out". Note: Outline differs from borders! Unlike border, the outline is drawn outside the element's border, and may overlap with OTHER content! */
}

.navbar-collapse {
    display: flex;
    flex-direction: column; /* By default, the flex-direction is "row", but we want it to be columns to get a vertical alignment! */
    justify-content: center; /* Horizontale Ausrichtung. */
    align-items: center; /* Vertikale Ausrichtung. */
    background: rgba(0, 0, 0, 0.90); /* ! Cool (Key to note): Wir fügen eine ganz leichte Transparenz in den schwarzen Hintergrund ein, weil dadurch der Nutzer sehen kann, dass - hinter dem Menu - . Dies führt dazu, dass er automatisch versuchen wird, auf das "Kreuz-Icon" zu drücken, um das Menu zu schliessen! */
    position: fixed; /* Very cool Layout-Trick (Key): This will place the 'nav-barcollaps'-div-element to be RELATIVE TO the viewport (= browserfenster) and NOT its parent-element (= navbar-div) anymore!!! We can now position the element with the 'top'-, 'left'-, 'right'- and 'bottom'-property, as well as the 'width'- & 'height'-property. */
    top: 0; /* We position the 'nav-barcollaps'-div-element at the very top of the viewport (= browserfenster). */
    left: 0; /* Since we put a padding over the parent-element-div (= 'navbar'-div), we also need to re-position the 'navbar-collapse'-div more to the left. */
    width: 100%; /* The 'navbar-collapse'-div should take the full width of the screen. */
    height: 100%; /* The 'navbar-collapse'-div should take the full heigth of the screen. */
    display: none; /*Cool (Key): By default, we don't want this part of the navigation to show up, that's why we hide it with 'display: none'.
    - TO-DO: später wieder ent-kommentieren! */
}

.showNav { /* Notice: we have camel-tow in this CSS-Class, which hints at that we will use it in our JS-File! */
    display: flex!important; /* The '!important'-rule, it will override ALL previous styling rules for that specific property on that element!
    */
}

.nav-hide-btn {
    position: absolute; /* Cool (Key): Because the collapsed-navigation takes on the full viewport (see 'navbar-collapse'-div, property 'display:fixed'), this is a rare case where we don't need to set a 'position: relative' to a parent element!! :O */
    top: 0;
    right: 0;
    margin: 1.4rem 2rem; /* Rand oben & unten entspricht 22.4px (= 16 * 1.4), sowie einen Rand von 32px (= 16 * 2) --> Wichtig: das sind diesselben Ränder-Massen wie beim 'navbar'-div-parent-element! */
    font-size: 1.8rem; /* 1.8rem entspricht 28.8px (= 16px * 1.8rem)*/
    cursor: pointer;
    color: #fff;
    background: transparent;
    border: none;
    outline: 0;
}

.navbar-nav { /* Diese Klasse ist unnötig, meiner Meinung nach ??? */
    display: flex;
    flex-direction: column;
}

.nav-item {
    list-style-type: none; /* So verschwinden die "Bullet-Points" bei den <ul>-Listenpunkten.*/
    padding: 0.2rem 3.6rem;
    margin: 1rem 0;
    text-align: center; /*Das ist notwendig, ansonsten sind alle <li>-Elemente linksbündig, da sie ja teil einer Liste sind... */
}

.nav-link{
    color: #fff;
    text-decoration: none; /* Links sollten nicht unterstrichen sein*/
    text-transform: uppercase;
    font-weight: 500;
    letter-spacing: 1px;
    transition: color 0.5s ease;
}

.nav-link:hover{
    color: #c7c7c7; /**/
}


/** ------ Slider-Styling ------ **/

.showcase-wrapper {
    height: 100vh; /* Full-Screen height. */
    position: relative; /* This is needed in order to be able to position the 3 Dots that will give a hint to the user at which slide he currently is. */
    overflow: hidden;
}

.showcase-content{ /* Styling Flex-Container. */
    height: 100%; /* Take full-screen height. */
    width: 100%; /* Full-screen width. */
    display: flex;
    transition: all 0.5s ease;
}

.showcase { /* Styling Flex-Items (& Grid-Container). 
        --> KEY: The Flex-Items will also - simultaneously - be a Grid-Container!! */
    min-width: 100%; /* Each Flexbox-Item should have a FIXED 100% width, relative to the viewport (= borwser-fenster)!! */
    display: grid; /* Default-Behavior: All Grid-Items become 1 column. */
    place-items: center; /* This will be the vertical & horizontal alignment for our Grid-ITEMS WITHIN each CELL.

    - Key to note 1: Since the 'place-items' can only be applied to a Grid- OR Flexbox-CONTAINER, we can conclude that this property is applied to our GRID-Container (and not to the Flexbox that we used on the 'showcase-content'-div above).

    - Key to note 2: This is a Short-Cut-Writing for the following two Grid OR Flexbox CSS-properties: 
        - 'justify-items'-property (= horizontal alignment for Flexbox)
        - 'align-content'-property (= this is the vertical-alignment, since - by Default - we have a flex-direction of 'row' in this case.)
    */
    place-content: center; /* We horizontally & vertically alignment for the Flexbox- OR Grid-CONTENT. Dadurch nimmt - vor allem - der Button nicht dies gesamte Breite (= Width) der Grid-Cell an.

    - Key to note 1: Since the 'place-content' can only be applied to a Grid- OR Flexbox-CONTAINER, we can conclude that this property is applied to our GRID-Container (and not to the Flexbox that we used on the 'showcase-content'-div above). 
        - What it does? --> It will center - horizontally AND vertically - the WHOLE content of each column RELATIVE TO the whole height of the column (= e.g. both items WITHIN each of the 3 columns will be placed into the center of their corresponding grid-container). 

    - Key to note 2: This is a Short-Cut-Writing for the following two Flexbox- OR Grid- CSS-properties: 
        - 'justify-content'-property (= horizontal alignment WITHIN the flex- / grid-container)
        - 'align-content'-property (= this is the vertical-alignment WITHIN the flex- / grid-container.)
    */
    color: #fff;
    text-align: center;
}

.showcase h1 {
    font-size: 1.8rem;
    width: 90%;
    margin: 1.5rem auto; /* Bringt mehr Luft zwischen Button & Titel. */
}

.showcase button {
    background: transparent;
    border: 2.5px solid #fff;
    color: #fff;
    font-family: inherit;
    text-transform: uppercase;
    padding: 0.8rem 1.4rem;
    outline: 0;
    cursor: pointer;
    transition: all 0.5s ease;
}

.showcase button:hover {
    background: #fff;
    color: #000;
}

/* - Button-Layout for Slider - */
.dotted-btns { /* -- Flex-Container -- */
    position: absolute; /* We need to place the dots with absolute positioning. */
    bottom: 2rem; /* To position our (absouletly positioned) container correctly. */
    display: flex;
    justify-content: center; /*Thanks to our flex-container, */
    width: 100%;
}

.dotted-btns span {
    margin: 0 0.5rem;
    color: #fff;
    font-size: 0.8rem;
    opacity: 0.9;
    cursor: pointer;
    transition: opacity 0.5s ease;
}

.dotted-btns span:hover {
    opacity: 0.7;
}

/* - Background Images for Slider - */
.showcase:nth-child(1){
    background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.5)), url(assets/image1.jpg) center/cover no-repeat;
}
.showcase:nth-child(2){
    background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.5)), url(assets/image2.jpg) center/cover no-repeat;
}
.showcase:nth-child(3){
    background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.5)), url(assets/image3.jpg) center/cover no-repeat;
}

/* - Responsiveness of Slider - */
@media screen and (min-width: 400px){
    .showcase h1{
        font-size: 4rem;
    }
}

@media screen and (min-width: 992px){
    .showcase h1{
        font-size: 5rem;
    }
    .showcase button{
        font-size: 1.05rem;
    }
}